---
title: k8s网络篇一-底层技术
date: 2024-08-21T18:35:54+08:00
lastmod: 2024-08-21T18:35:54+08:00
author: wantflying
authorlink: https://github.com/wantflying
cover: /img/cover.jpg
categories:
  - k8s
tags:
  - 网络
  - Linux
draft: false
---

    k8s向我们提供各种网络插件、网络资源，例如Flannel、Calico、Cilium、Weave各种网络插件。在使用之前我们需要理解它们是如何工作的，这样才能在遇到问题时能有清晰的认识，能够知其所以然。本文将依次介绍Linux为我们提供的工具：namespace、veth pair、iptables、Linux bridge、tun/tap设备、iptables、ipip、vxlan、macvlan、ipvlan，以及当前最新的ebpf技术，这个后续开单独模块介绍。

<!--more-->

# namespace

- **作用：** 为进程提供一个隔离的环境，从进程角度来看，整个服务器就它一个进程存在，完全独占系统资源，Linux 在各个内核版本升级过程中给我们提供了不同的 namespace 隔离，包括存储挂载、系统信号量、网络、主机名、进程、cgroup
- **原理：** Linux 使用 clone()函数创建 namespace，会在/proc/pid/ns 目录下生成符号链接，链接到对应文件，只要文件一直存在，namespace 就不会消失。通过 setns()方法可以将进程放入指定 namespace，unshare()可以将指定进程从 namespace 移出。例如我们如果要进入某个 namesapce 下，也是要先拿到 namespace 对应的文件描述符，然后通过 setns 添加进程，然后就可以执行自己的程序。至于这些函数底层原理是什么，感兴趣自行了解。

# veth pair

- **作用：** veth 就是一个虚拟以太网卡，pair 就是一对的意思，那么一对虚拟网卡就是说我们往其中一个 veth 发送数据，就会转发到另外一个 veth，要注意 veth pair 的作用仅仅是将数据从一个网卡发送到另外一个网卡，前面我们也提到 namesapce 网络空间隔离，那我们就可以把 veth 放在根命令空间和新的网络空间，实现有限制的网络访问。
  ![](https://raw.githubusercontent.com/wantflying/blog/main/static/img/vethpair-1.png)如上图所示，当前服务器只有一个默认的 ens160 网卡，我们可以通过 _ip link add vethname1 type veth peer name vethname2_，创建一对 veth pair，当前这一对 veth 都是在根 namespace 下，且网卡状态都是 down，也就是当前没啥用，只是单纯创建出来。
  ![](https://raw.githubusercontent.com/wantflying/blog/main/static/img/vethpair-2.png)
  接下来将两个 veth 启动并设置两个不同的网段，veth1 的 IP 地址是 10.0.2.100，veth0 的地址是 10.0.1.100。
  ![](https://raw.githubusercontent.com/wantflying/blog/main/static/img/vethpair-3.png)
  此时我们在根 namespace ping veth1 和 veth0 都可以 ping 通，路由表也可以看到分别创建了两条路由规则，这个时候其实跟pair没啥关系，单纯可以理解就是分别创建了两个不同的虚拟网卡，只有他们在不同的网络namespace才能感受到pair的意义。接着我们通过 ip netns 创建两个不同的命令空间，这个是 linux 为我们封装好的一个工具去操作网络 namespace，其他 namespace 的操作都需要编写相应的 c 代码。接着再把 veth0 放入 netns0 空间，veth1 放到 netns1 空间，此时我们再去 ping 这两个网址，已经无法 ping 通，因为他们分别处在不同的网络namespace。此时如果进入netns0或者netns1，可以看到网卡已经被重置变成down状态，路由表信息也是全为空的。
![](https://raw.githubusercontent.com/wantflying/blog/main/static/img/vethpair-4.png) 
如上图所示，我们再次把veth0和veth1启动起来，然后在netns0的空间下去ping veth1，发现ping不通，那么问题来了不是说两个是个pair吗？可以互相通的？但是这是我们逻辑上的理解，那还是要强调一下pair的作用：**将一端网卡的数据传送到另外一端**。是不是可以看出问题所在，我们需要先将数据送到我们的网卡上，那这个原因是本地路由没有10.0.2.0/24，所以我们的数据压根送不到我们自己的veth0网卡上，所以我们只要给我们的namespace添加一条路由即可。但是这也只是解决了报文去的问题，回的问题也需要在netns1上创建相应的路由。至此跨namespace的网络访问就可以通了，对于各自namespace的网络设备都是独立的，其实如果vth0和veth1如果是在同一网段，那么也就可以直接使用默认的路由规则进行访问，无须手工添加路由规则。